import { NextRequest, NextResponse } from 'next/server';
import { Idea } from '@/types';
import jsPDF from 'jspdf';

// PDF Export using jsPDF
async function generatePDF(idea: Idea): Promise<Buffer> {
  const doc = new jsPDF();
  let yPosition = 20;
  const pageHeight = doc.internal.pageSize.height;
  const margin = 20;
  const maxWidth = doc.internal.pageSize.width - (margin * 2);

  // Helper function to add text with word wrapping
  const addText = (text: string, fontSize: number = 12, isBold: boolean = false) => {
    doc.setFontSize(fontSize);
    if (isBold) {
      doc.setFont('helvetica', 'bold');
    } else {
      doc.setFont('helvetica', 'normal');
    }
    
    const lines = doc.splitTextToSize(text, maxWidth);
    const lineHeight = fontSize * 0.4;
    
    // Check if we need a new page
    if (yPosition + (lines.length * lineHeight) > pageHeight - margin) {
      doc.addPage();
      yPosition = 20;
    }
    
    doc.text(lines, margin, yPosition);
    yPosition += lines.length * lineHeight + 5;
  };

  // Helper function to add a new page if needed
  const checkNewPage = () => {
    if (yPosition > pageHeight - 40) {
      doc.addPage();
      yPosition = 20;
    }
  };

  // Title
  addText(idea.title, 18, true);
  yPosition += 10;

  // Problem Statement
  addText('Problem Statement', 14, true);
  addText(idea.problem_text, 12);
  yPosition += 10;

  // Summary
  addText('Summary', 14, true);
  addText(idea.summary, 12);
  yPosition += 10;

  // Solution Concepts
  addText('Solution Concepts', 14, true);
  idea.solutions.forEach((solution, index) => {
    checkNewPage();
    addText(`${index + 1}. ${solution.title}`, 12, true);
    addText(solution.description, 11);
    addText(`Stakeholders: ${solution.stakeholders.join(', ')}`, 10);
    addText(`Tech Stack: ${solution.tech_stack.join(', ')}`, 10);
    addText(`Effort Level: ${solution.effort_level} | Impact: ${solution.impact_estimate}`, 10);
    yPosition += 5;
  });

  // Implementation Roadmap
  addText('Implementation Roadmap', 14, true);
  idea.roadmap.forEach(phase => {
    checkNewPage();
    addText(phase.phase, 12, true);
    phase.tasks.forEach(task => {
      addText(`â€¢ ${task}`, 11);
    });
    yPosition += 5;
  });

  // Suggested Partners
  if (idea.partners.length > 0) {
    addText('Suggested Partners', 14, true);
    idea.partners.forEach(partner => {
      checkNewPage();
      addText(`${partner.name} (${partner.type})`, 12, true);
      addText(partner.reason, 11);
      if (partner.contact_link) {
        addText(`Contact: ${partner.contact_link}`, 10);
      }
      yPosition += 5;
    });
  }

  // Tags
  if (idea.tags.length > 0) {
    addText('Tags', 14, true);
    addText(idea.tags.join(', '), 11);
  }

  // Footer
  checkNewPage();
  yPosition = pageHeight - 20;
  addText(`Generated by OpenIdeaX on ${new Date().toLocaleDateString()}`, 8);

  // Convert to Buffer
  const pdfOutput = doc.output('arraybuffer');
  return Buffer.from(pdfOutput);
}

// GitHub Repo Seeding
async function createGitHubRepo(idea: Idea): Promise<string> {
  const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
  
  if (!GITHUB_TOKEN) {
    throw new Error('GitHub token not configured');
  }

  // Create repository
  const repoResponse = await fetch('https://api.github.com/user/repos', {
    method: 'POST',
    headers: {
      'Authorization': `token ${GITHUB_TOKEN}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      name: `openideax-${idea.id}`,
      description: idea.summary,
      private: false,
      auto_init: true
    })
  });

  if (!repoResponse.ok) {
    throw new Error('Failed to create GitHub repository');
  }

  const repo = await repoResponse.json();
  const repoUrl = repo.html_url;

  // Create issues for the roadmap
  const issues = idea.roadmap.flatMap(phase => 
    phase.tasks.map(task => ({
      title: `${phase.phase}: ${task}`,
      body: `**Phase:** ${phase.phase}\n\n**Task:** ${task}\n\n**Related to:** ${idea.title}\n\n**Generated by OpenIdeaX**`,
      labels: ['open-source', 'collaboration', 'roadmap']
    }))
  );

  // Create issues (limit to 5 as per PRD)
  const limitedIssues = issues.slice(0, 5);
  
  for (const issue of limitedIssues) {
    try {
      await fetch(`https://api.github.com/repos/${repo.full_name}/issues`, {
        method: 'POST',
        headers: {
          'Authorization': `token ${GITHUB_TOKEN}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(issue)
      });
  } catch (error) {
      console.error('Error creating issue:', error);
    }
  }

  // Create README.md
  const readmeContent = `# ${idea.title}

## Problem Statement
${idea.problem_text}

## Summary
${idea.summary}

## Solution Concepts
${idea.solutions.map((solution, index) => `
### ${index + 1}. ${solution.title}
${solution.description}

**Stakeholders:** ${solution.stakeholders.join(', ')}
**Tech Stack:** ${solution.tech_stack.join(', ')}
**Effort Level:** ${solution.effort_level}
**Impact Estimate:** ${solution.impact_estimate}
`).join('\n')}

## Implementation Roadmap
${idea.roadmap.map(phase => `
### ${phase.phase}
${phase.tasks.map(task => `- ${task}`).join('\n')}
`).join('\n')}

## Suggested Partners
${idea.partners.map(partner => `
### ${partner.name} (${partner.type})
${partner.reason}
${partner.contact_link ? `Contact: ${partner.contact_link}` : ''}
`).join('\n')}

## Getting Started
1. Review the roadmap issues
2. Join the collaboration room
3. Start with the first phase tasks
4. Contribute to the solution development

## License
This project is open source and available under the MIT License.

---
Generated by [OpenIdeaX](https://openideax.com) - AI-Powered Innovation Platform
  `;

  // Update README.md
  try {
    await fetch(`https://api.github.com/repos/${repo.full_name}/contents/README.md`, {
      method: 'PUT',
      headers: {
        'Authorization': `token ${GITHUB_TOKEN}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: 'Add project README',
        content: Buffer.from(readmeContent).toString('base64')
      })
    });
  } catch (error) {
    console.error('Error updating README:', error);
  }

  return repoUrl;
}

// Outreach Email Template
function generateOutreachEmail(idea: Idea, partner: any): string {
  return `
Subject: Collaboration Opportunity - ${idea.title}

Dear ${partner.name} Team,

I hope this email finds you well. I'm reaching out regarding a potential collaboration opportunity that aligns with your mission and expertise.

## Project Overview
**Title:** ${idea.title}
**Problem:** ${idea.problem_text}
**Summary:** ${idea.summary}

## Why We Think You'd Be a Great Partner
${partner.reason}

## What We're Looking For
- Expertise in ${partner.type}
- Potential collaboration on implementation
- Knowledge sharing and best practices
- Network connections

## Next Steps
If this opportunity interests you, we'd love to:
1. Schedule a brief call to discuss the project
2. Share more detailed implementation plans
3. Explore potential collaboration models

## Project Repository
You can find the full project details and roadmap at: [GitHub Repository Link]

## About OpenIdeaX
This project was generated using OpenIdeaX, an AI-powered platform for collaborative innovation. We're committed to open-source solutions that create real social impact.

Thank you for your time and consideration. I look forward to hearing from you.

Best regards,
[Your Name]
[Your Contact Information]

---
Generated by OpenIdeaX - AI-Powered Innovation Platform
  `;
}

export async function POST(request: NextRequest) {
  try {
    const { idea, format, partner } = await request.json();
    
    if (!idea) {
      return NextResponse.json({ error: 'Idea is required' }, { status: 400 });
    }

    switch (format) {
      case 'pdf':
        try {
          const pdfBuffer = await generatePDF(idea);
          return new NextResponse(pdfBuffer as any, {
            headers: {
              'Content-Type': 'application/pdf',
              'Content-Disposition': `attachment; filename="${idea.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.pdf"`
            }
          });
        } catch (error) {
          return NextResponse.json({ error: 'Failed to generate PDF' }, { status: 500 });
        }

      case 'github':
        try {
          const repoUrl = await createGitHubRepo(idea);
          return NextResponse.json({
            success: true,
            repoUrl,
            message: 'GitHub repository created successfully'
          });
        } catch (error) {
          return NextResponse.json({ error: 'Failed to create GitHub repository' }, { status: 500 });
        }

      case 'email':
        if (!partner) {
          return NextResponse.json({ error: 'Partner information is required for email generation' }, { status: 400 });
        }
        
        const emailTemplate = generateOutreachEmail(idea, partner);
        return NextResponse.json({
          success: true,
          emailTemplate,
          message: 'Outreach email generated successfully'
        });

      default:
        return NextResponse.json({ error: 'Invalid export format' }, { status: 400 });
    }

  } catch (error) {
    console.error('Export error:', error);
    return NextResponse.json(
      { error: 'Failed to export' },
      { status: 500 }
    );
  }
}